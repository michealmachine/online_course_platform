# Auth服务组件迁移到Base模块指南

## 迁移目标

将auth_service中的RBAC和JWT相关组件迁移到base模块，使各服务能自验证token并进行权限控制，同时不影响现有auth服务的功能。

## 迁移顺序与步骤

### 1. 基础模型迁移

首先迁移基础模型和枚举，这些组件依赖少，迁移风险低。

#### 1.1 迁移权限类型枚举

`PermissionType`枚举已存在于base模块，无需迁移。

#### 1.2 迁移基础模型

创建以下包结构：
```
com.double2and9.base.auth.model
```

迁移以下类：
- 从auth_service迁移JWT相关DTO到base.auth.model.jwt
  - 创建TokenPayload类存储令牌载荷
  - 创建JwtToken类表示JWT令牌

### 2. 工具类迁移

其次迁移工具类，这些通常是无状态的，依赖较少。

#### 2.1 创建工具类包结构

```
com.double2and9.base.auth.util
```

#### 2.2 迁移JWT工具类

从`JwtTokenProvider`提取核心功能，创建`JwtUtils`：
```java
public class JwtUtils {
    // 生成令牌
    public static String generateToken(String secret, Map<String, Object> claims, long expirationSeconds) {...}
    
    // 验证令牌
    public static Claims validateToken(String token, String secret) {...}
    
    // 解析令牌
    public static Claims parseToken(String token, String secret) {...}
}
```

#### 2.3 迁移PKCE工具类

将`PKCEUtils`迁移到base.auth.util：
```java
public class PKCEUtils {
    public static boolean verifyCodeChallenge(String codeVerifier, String codeChallenge, String codeChallengeMethod) {...}
    public static String computeCodeChallenge(String codeVerifier, String method) {...}
}
```

### 3. 依赖调整

由于要迁移缓存组件，需要在base模块中添加Redis依赖。

#### 3.1 在base模块的pom.xml中添加Redis依赖

```xml
<!-- Redis依赖 -->
<dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-redis</artifactId>
    <optional>true</optional> <!-- 标记为可选依赖，使依赖此模块的项目不会强制继承Redis依赖 -->
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <optional>true</optional>
</dependency>
```

#### 3.2 添加Jackson依赖用于序列化

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.datatype</groupId>
    <artifactId>jackson-datatype-jsr310</artifactId>
    <optional>true</optional>
</dependency>
```

### 4. 缓存管理迁移

迁移权限缓存管理组件，提高权限验证性能。

#### 4.1 创建缓存接口

创建包结构：
```
com.double2and9.base.auth.cache
```

创建缓存接口：
```java
public interface PermissionCacheService {
    void cachePermissionTree(List<?> tree);
    List<?> getPermissionTree();
    void clearPermissionTree();
    void clearRolePermissions(Long roleId);
    void clearAllCaches();
}
```

#### 4.2 迁移Redis实现

将PermissionCacheManager迁移到base模块：
```java
public class RedisPermissionCacheManager implements PermissionCacheService {
    private final RedisTemplate<String, Object> redisTemplate;
    private static final String PERMISSION_TREE_KEY = "permission:tree";
    private static final String ROLE_PERMISSIONS_KEY = "role:permissions:";
    private static final long CACHE_TTL = 24; // 24小时
    
    // 原有实现方法
    public void cachePermissionTree(List<?> tree) {...}
    public List<?> getPermissionTree() {...}
    public void clearPermissionTree() {...}
    public void clearRolePermissions(Long roleId) {...}
    public void clearAllCaches() {...}
}
```

#### 4.3 添加缓存配置类

创建Redis缓存配置类，确保序列化正确处理：
```java
public class RedisCacheConfig {
    @Bean
    @ConditionalOnMissingBean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.activateDefaultTyping(
            objectMapper.getPolymorphicTypeValidator(),
            ObjectMapper.DefaultTyping.NON_FINAL,
            JsonTypeInfo.As.PROPERTY
        );
        
        GenericJackson2JsonRedisSerializer jsonRedisSerializer = 
            new GenericJackson2JsonRedisSerializer(objectMapper);
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        
        template.setKeySerializer(stringRedisSerializer);
        template.setHashKeySerializer(stringRedisSerializer);
        template.setValueSerializer(jsonRedisSerializer);
        template.setHashValueSerializer(jsonRedisSerializer);
        
        template.afterPropertiesSet();
        
        return template;
    }
}
```

### 5. RBAC接口与实现迁移

这是迁移的核心部分，需要先定义接口，再迁移实现。

#### 5.1 定义RBAC模型接口

创建包结构：
```
com.double2and9.base.auth.rbac
```

创建以下接口：
```java
// 用户接口
public interface AuthUser {
    Long getId();
    String getUsername();
    boolean isEnabled();
    Collection<? extends AuthRole> getRoles();
}

// 角色接口
public interface AuthRole {
    Long getId();
    String getName();
    Collection<? extends AuthPermission> getPermissions();
}

// 权限接口
public interface AuthPermission {
    Long getId();
    String getName();
    String getResource();
    String getAction();
    PermissionType getType();
}
```

#### 5.2 提取权限检查逻辑

创建`PermissionChecker`类：
```java
public class PermissionChecker {
    public static boolean hasPermission(AuthUser user, String resource, String action) {...}
    public static boolean hasRole(AuthUser user, String roleName) {...}
    public static Set<String> getPermissionScopes(AuthUser user) {...}
}
```

### 6. JWT认证组件迁移

将JWT验证和处理相关组件迁移到base。

#### 6.1 创建JWT接口

创建包结构：
```
com.double2and9.base.auth.jwt
```

创建以下接口：
```java
// JWT配置接口
public interface JwtProperties {
    String getSecret();
    long getExpirationSeconds();
}

// JWT验证接口
public interface TokenVerifier {
    boolean isTokenValid(String token);
    Claims parseToken(String token);
    String getUsernameFromToken(String token);
    String getClientIdFromToken(String token, String clientIdClaimName);
}
```

#### 6.2 实现JWT组件

创建`JwtTokenVerifier`实现：
```java
public class DefaultTokenVerifier implements TokenVerifier {
    private final JwtProperties jwtProperties;
    
    // 构造函数，依赖注入
    
    @Override
    public boolean isTokenValid(String token) {...}
    
    @Override
    public Claims parseToken(String token) {...}
    
    @Override
    public String getUsernameFromToken(String token) {...}
    
    @Override
    public String getClientIdFromToken(String token, String clientIdClaimName) {...}
}
```

### 7. 迁移黑名单服务

令牌黑名单是确保令牌可撤销的关键组件。

#### 7.1 创建黑名单接口

```java
public interface TokenBlacklistService {
    void addToBlacklist(String token, long expirationTime);
    boolean isBlacklisted(String token);
}
```

#### 7.2 迁移Redis实现

```java
public class RedisTokenBlacklistService implements TokenBlacklistService {
    private final RedisTemplate<String, String> redisTemplate;
    private static final String BLACKLIST_PREFIX = "token:blacklist:";
    
    // 实现接口方法
}
```

### 8. 测试代码迁移

为确保迁移组件的正确性，需要迁移相关测试代码。

#### 8.1 迁移单元测试

从auth_service迁移关键测试到base模块：
- PermissionCacheManagerTest
- JwtTokenProviderTest/JwtUtilsTest
- PKCEUtilsTest
- TokenBlacklistServiceTest

#### 8.2 编写集成测试

创建集成测试验证组件之间的交互：
- Redis缓存功能测试
- JWT验证与黑名单集成测试

### 9. Auth服务适配改造

最后适配auth_service使用新的base组件。

#### 9.1 让实体类实现接口

修改User、Role、Permission类，实现AuthUser、AuthRole、AuthPermission接口：

```java
public class User implements AuthUser {
    // 已有属性和方法
    
    // 实现接口方法
}
```

#### 9.2 改造JwtTokenProvider

修改JwtTokenProvider，使用JwtUtils工具类：
```java
public class JwtTokenProvider implements TokenVerifier {
    @Value("${jwt.secret}")
    private String jwtSecret;
    
    // 修改方法使用JwtUtils
    public String generateToken(Map<String, Object> claims, long expirationSeconds) {
        return JwtUtils.generateToken(jwtSecret, claims, expirationSeconds);
    }
    
    // 实现TokenVerifier接口
}
```

#### 9.3 改造TokenBlacklistService

修改TokenBlacklistService，继承base中的接口：
```java
public class TokenBlacklistServiceImpl extends RedisTokenBlacklistService {
    // 使用父类实现，减少代码
}
```

#### 9.4 改造PermissionCacheManager

修改PermissionCacheManager，使用base模块中的实现：
```java
@Component
public class PermissionCacheManagerImpl extends RedisPermissionCacheManager {
    // 继承base中的实现
}
```

## 迁移注意事项

1. **增量迁移**：按上述顺序逐步迁移，每步完成后进行测试
2. **接口隔离**：通过接口解耦，允许多种实现
3. **依赖管理**：确保base模块不引入不必要的依赖，使用optional标签
4. **向后兼容**：保持原有API不变，确保不影响现有功能
5. **测试覆盖**：每个迁移步骤都应编写对应测试
6. **条件配置**：使用Spring Boot的条件注解确保组件可选

## 迁移后的使用示例

### 在其他服务中使用JWT验证

```java
@Service
public class SomeService {
    private final TokenVerifier tokenVerifier;
    
    // 构造函数注入
    
    public void doSomething(String token) {
        if (tokenVerifier.isTokenValid(token)) {
            String username = tokenVerifier.getUsernameFromToken(token);
            // 继续业务逻辑
        }
    }
}
```

### 在其他服务中使用权限检查

```java
@Service
public class SomeService {
    public void checkPermission(AuthUser user, String resource, String action) {
        if (!PermissionChecker.hasPermission(user, resource, action)) {
            throw new AccessDeniedException("无权限执行此操作");
        }
        // 继续业务逻辑
    }
}
```

### 集成Redis缓存

```java
@Configuration
@EnableCaching
public class CacheConfig {
    @Bean
    public PermissionCacheService permissionCacheService(RedisTemplate<String, Object> redisTemplate) {
        return new RedisPermissionCacheManager(redisTemplate);
    }
}
```
