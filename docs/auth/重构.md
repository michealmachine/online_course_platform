# 认证服务重构计划

## 1. 重构目标

1. 移除直接API认证方式，统一使用OAuth2/OIDC标准流程
2. 保留基于表单的登录和注册页面，但集成到OAuth2流程中
3. 优化JWT处理逻辑，将OIDC令牌验证功能开放给其他服务
4. 简化代码结构，减少重复逻辑
5. 确保所有客户端都通过OAuth2/OIDC流程获取令牌

## 2. 现状分析

### 2.1 现有认证方式

1. 直接API认证：
   - `/api/auth/login` 和 `/api/auth/register` 端点
   - 直接生成JWT令牌
   - 使用 `JwtAuthenticationFilter` 验证

2. OAuth2/OIDC认证：
   - 标准的授权码流程
   - 支持PKCE
   - 完整的OIDC实现
   - 会话管理

### 2.2 问题点

1. 认证逻辑重复：
   - JWT生成存在于多个地方
   - 权限验证逻辑不统一

2. 安全配置混乱：
   - `SecurityConfig` 中混合了多种配置
   - 权限规则分散

3. 会话管理不一致：
   - API认证使用无状态JWT
   - OAuth2使用会话管理

## 3. 具体修改步骤

### 步骤1：重构安全配置

1. 修改 `SecurityConfig.java`：
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) {
        http
            .authorizeHttpRequests(authorize -> authorize
                // OIDC端点
                .requestMatchers(
                    "/.well-known/openid-configuration",
                    "/oauth2/jwks",
                    "/oauth2/check-session",
                    "/oauth2/end-session"
                ).permitAll()
                // OAuth2端点
                .requestMatchers(
                    "/oauth2/token",
                    "/oauth2/authorize",
                    "/oauth2/consent"
                ).permitAll()
                // 登录注册
                .requestMatchers(
                    "/auth/login",
                    "/auth/register"
                ).permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage("/auth/login")
                .permitAll()
            )
            .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
        return http.build();
    }
}
```

### 步骤2：修改登录流程

1. 更新 `LoginController.java`：
```java
@Controller
@RequestMapping("/auth")
public class LoginController {
    private final AuthorizationRequestService authorizationRequestService;
    
    @PostMapping("/login")
    public String processLogin(
        @Valid LoginRequest loginRequest,
        BindingResult bindingResult,
        HttpServletRequest request,
        HttpServletResponse response
    ) {
        if (bindingResult.hasErrors()) {
            return "auth/login";
        }

        try {
            // 使用Spring Security进行认证
            Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                    loginRequest.getUsername(),
                    loginRequest.getPassword()
                )
            );
            
            SecurityContextHolder.getContext().setAuthentication(authentication);

            // 检查是否有待处理的OAuth2授权请求
            OAuth2AuthorizationRequest authRequest = 
                authorizationRequestService.getAuthorizationRequest(request, response);
                
            if (authRequest != null) {
                // 继续OAuth2授权流程
                return "redirect:/oauth2/authorize?" + authRequest.toQueryString();
            }

            return "redirect:/";
        } catch (AuthenticationException e) {
            return "redirect:/auth/login?error=" + e.getMessage();
        }
    }
}
```

### 步骤3：修改认证服务

1. 更新 `AuthService.java`：
```java
@Service
@RequiredArgsConstructor
public class AuthService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final AuthenticationManager authenticationManager;

    @Transactional
    public void register(RegisterRequest request) {
        // 验证用户名和邮箱是否存在
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new AuthException(AuthErrorCode.USERNAME_ALREADY_EXISTS);
        }

        // 创建用户
        User user = new User();
        user.setUsername(request.getUsername());
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        user.setEmail(request.getEmail());
        
        userRepository.save(user);
    }

    public void authenticate(String username, String password) {
        Authentication authentication = authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(username, password)
        );
        SecurityContextHolder.getContext().setAuthentication(authentication);
    }
}
```

### 步骤4：清理不需要的代码

1. 删除文件：
   - `AuthController.java`
   - `AuthResponse.java`
   - `JwtAuthenticationFilter.java`

2. 移除代码：
   - 从 `AuthService` 移除 JWT 相关方法
   - 从 `SecurityConfig` 移除 JWT 过滤器配置

### 步骤5：更新OAuth2/OIDC配置

1. 修改 `AuthorizationServerConfig.java`：
```java
@Configuration
public class AuthorizationServerConfig {
    @Bean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) {
        OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);
        
        http.getConfigurer(OAuth2AuthorizationServerConfigurer.class)
            .authorizationEndpoint(endpoint ->
                endpoint.consentPage("/oauth2/consent"))
            .oidc(Customizer.withDefaults());
            
        http.exceptionHandling(exceptions ->
            exceptions.authenticationEntryPoint(
                new LoginUrlAuthenticationEntryPoint("/auth/login")
            ));
            
        return http.build();
    }
}
```

2. 确保 `application.yml` 配置正确：
```yaml
spring:
  security:
    oauth2:
      authorization-server:
        issuer: http://localhost:8084
        endpoint:
          authorization: /oauth2/authorize
          token: /oauth2/token
          jwk-set: /oauth2/jwks
          oidc:
            userinfo: /oauth2/userinfo
```

### 步骤6：更新客户端配置

1. 修改内部客户端配置：
```java
@Bean
public RegisteredClient webClient() {
    return RegisteredClient.withId(UUID.randomUUID().toString())
        .clientId("web-client")
        .clientSecret(passwordEncoder.encode("web-client-secret"))
        .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
        .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
        .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
        .redirectUri("http://localhost:3000/callback")
        .scope("openid")
        .scope("profile")
        .scope("email")
        .clientSettings(ClientSettings.builder()
            .requireAuthorizationConsent(false)
            .requireProofKey(true)
            .build())
        .build();
}
```

## 4. 数据库修改

### 4.1 数据库结构

1. 用户相关表：
```sql
-- 用户表
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    enabled BOOLEAN DEFAULT TRUE,
    nickname VARCHAR(50),
    phone VARCHAR(20),
    avatar VARCHAR(255),
    account_locked BOOLEAN DEFAULT FALSE,
    login_attempts INT DEFAULT 0,
    lock_time TIMESTAMP,
    last_login_time TIMESTAMP,
    last_login_ip VARCHAR(50),
    organization_id BIGINT,
    given_name VARCHAR(50),
    family_name VARCHAR(50),
    middle_name VARCHAR(50),
    preferred_username VARCHAR(50),
    profile VARCHAR(255),
    website VARCHAR(255),
    gender VARCHAR(10),
    birthdate VARCHAR(10),
    zoneinfo VARCHAR(40),
    locale VARCHAR(10),
    email_verified BOOLEAN DEFAULT FALSE,
    phone_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 角色和权限表
CREATE TABLE roles (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description VARCHAR(500)
);

CREATE TABLE permissions (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description VARCHAR(200),
    resource VARCHAR(100) NOT NULL,
    action VARCHAR(50) NOT NULL,
    type VARCHAR(20) NOT NULL DEFAULT 'API',
    scope VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

2. OAuth2相关表：
```sql
-- OAuth2客户端表
CREATE TABLE oauth2_registered_client (
    id VARCHAR(100) NOT NULL PRIMARY KEY,
    client_id VARCHAR(100) NOT NULL,
    client_id_issued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    client_secret VARCHAR(200),
    client_secret_expires_at TIMESTAMP,
    client_name VARCHAR(200) NOT NULL,
    client_authentication_methods VARCHAR(1000) NOT NULL,
    authorization_grant_types VARCHAR(1000) NOT NULL,
    redirect_uris VARCHAR(1000),
    post_logout_redirect_uris VARCHAR(1000),
    scopes VARCHAR(1000) NOT NULL,
    client_settings VARCHAR(2000) NOT NULL,
    token_settings VARCHAR(2000) NOT NULL,
    is_internal BOOLEAN DEFAULT FALSE,
    auto_approve BOOLEAN DEFAULT FALSE
);

-- OAuth2授权表
CREATE TABLE oauth2_authorization (
    id VARCHAR(100) NOT NULL PRIMARY KEY,
    registered_client_id VARCHAR(100) NOT NULL,
    principal_name VARCHAR(200) NOT NULL,
    authorization_grant_type VARCHAR(100) NOT NULL,
    authorized_scopes VARCHAR(1000),
    attributes LONGTEXT,
    state VARCHAR(500),
    authorization_code_value LONGTEXT,
    authorization_code_issued_at TIMESTAMP,
    authorization_code_expires_at TIMESTAMP,
    authorization_code_metadata LONGTEXT,
    access_token_value LONGTEXT,
    access_token_issued_at TIMESTAMP,
    access_token_expires_at TIMESTAMP,
    access_token_metadata LONGTEXT,
    access_token_type VARCHAR(100),
    access_token_scopes VARCHAR(1000),
    refresh_token_value LONGTEXT,
    refresh_token_issued_at TIMESTAMP,
    refresh_token_expires_at TIMESTAMP,
    refresh_token_metadata LONGTEXT,
    oidc_id_token_value LONGTEXT,
    oidc_id_token_issued_at TIMESTAMP,
    oidc_id_token_expires_at TIMESTAMP,
    oidc_id_token_metadata LONGTEXT,
    oidc_id_token_claims LONGTEXT,
    user_code_value VARCHAR(100),
    user_code_issued_at TIMESTAMP,
    user_code_expires_at TIMESTAMP,
    user_code_metadata LONGTEXT,
    device_code_value VARCHAR(100),
    device_code_issued_at TIMESTAMP,
    device_code_expires_at TIMESTAMP,
    device_code_metadata LONGTEXT
);

-- OAuth2授权确认表
CREATE TABLE oauth2_authorization_consent (
    registered_client_id VARCHAR(100) NOT NULL,
    principal_name VARCHAR(200) NOT NULL,
    authorities VARCHAR(1000) NOT NULL,
    PRIMARY KEY (registered_client_id, principal_name)
);

-- OAuth2授权码表
CREATE TABLE oauth2_authorization_code (
    id VARCHAR(36) PRIMARY KEY,
    client_id VARCHAR(100) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    code VARCHAR(255) NOT NULL,
    scope VARCHAR(1000),
    redirect_uri VARCHAR(1000),
    expires_at TIMESTAMP NOT NULL,
    code_challenge VARCHAR(128),
    code_challenge_method VARCHAR(10),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### 4.2 数据迁移

1. 更新客户端配置：
```sql
-- 确保所有客户端启用PKCE
UPDATE oauth2_registered_client
SET client_settings = JSON_SET(
    client_settings,
    '$.requireProofKey',
    'true'
)
WHERE JSON_EXTRACT(client_settings, '$.requireProofKey') IS NULL
OR JSON_EXTRACT(client_settings, '$.requireProofKey') = 'false';

-- 更新内部客户端配置
UPDATE oauth2_registered_client
SET is_internal = true,
    auto_approve = true
WHERE client_id IN ('web-client', 'mobile-client');

-- 更新客户端授权类型
UPDATE oauth2_registered_client
SET authorization_grant_types = 'authorization_code refresh_token'
WHERE authorization_grant_types NOT LIKE '%authorization_code%';
```

2. 更新权限数据：
```sql
-- 添加OAuth2相关权限
INSERT INTO permissions (name, description, resource, action, type, scope) VALUES
('oauth2_read_profile', '读取用户档案', 'profile', 'read', 'OAUTH2', 'read'),
('oauth2_write_profile', '更新用户档案', 'profile', 'write', 'OAUTH2', 'write'),
('oauth2_read_email', '读取邮箱', 'email', 'read', 'OAUTH2', 'email'),
('oauth2_read_phone', '读取手机号', 'phone', 'read', 'OAUTH2', 'phone'),
('oauth2_read_address', '读取地址', 'address', 'read', 'OAUTH2', 'address');

-- 更新现有权限的类型
UPDATE permissions 
SET type = 'API'
WHERE type IS NULL;
```

3. 清理冗余数据：
```sql
-- 删除未使用的授权记录
DELETE FROM oauth2_authorization 
WHERE access_token_expires_at < NOW();

-- 删除过期的授权码
DELETE FROM oauth2_authorization_code 
WHERE expires_at < NOW();
```

### 4.3 索引优化

1. 用户相关索引：
```sql
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_organization_id ON users(organization_id);
```

2. OAuth2相关索引：
```sql
CREATE INDEX idx_oauth2_registered_client_cid ON oauth2_registered_client(client_id);
CREATE INDEX idx_oauth2_authorization_pn ON oauth2_authorization(principal_name);
CREATE INDEX idx_oauth2_authorization_code ON oauth2_authorization(authorization_code_value(255));
CREATE INDEX idx_oauth2_authorization_access_token ON oauth2_authorization(access_token_value(255));
CREATE INDEX idx_oauth2_authorization_refresh_token ON oauth2_authorization(refresh_token_value(255));
CREATE INDEX idx_oauth2_authorization_device_code ON oauth2_authorization(device_code_value);
CREATE INDEX idx_oauth2_authorization_user_code ON oauth2_authorization(user_code_value);
CREATE INDEX idx_oauth2_registered_client_internal ON oauth2_registered_client(is_internal);
```

### 4.4 回滚计划

1. 结构回滚：
```sql
-- 删除新增的列
ALTER TABLE oauth2_registered_client
DROP COLUMN is_internal,
DROP COLUMN auto_approve,
DROP COLUMN post_logout_redirect_uris;

-- 删除新增的表
DROP TABLE IF EXISTS oauth2_authorization_code;

-- 删除新增的索引
DROP INDEX idx_oauth2_authorization_device_code ON oauth2_authorization;
DROP INDEX idx_oauth2_authorization_user_code ON oauth2_authorization;
DROP INDEX idx_oauth2_registered_client_internal ON oauth2_registered_client;
```

2. 数据回滚：
```sql
-- 恢复客户端设置
UPDATE oauth2_registered_client
SET client_settings = JSON_REMOVE(
    client_settings,
    '$.requireProofKey'
);

-- 删除OAuth2权限
DELETE FROM permissions 
WHERE type = 'OAUTH2';
```

## 5. 测试修改

### 5.1 基础测试设施

1. 基础OAuth2集成测试类：
```java
@SpringBootTest
@AutoConfigureMockMvc
public abstract class BaseOAuth2IntegrationTest {
    protected MockMvc mockMvc;
    protected MockHttpSession session;
    protected String codeVerifier;
    protected String codeChallenge;
    protected String state;
    protected String nonce;
    protected RegisteredClient firstPartyClient;
    
    @BeforeEach
    public void setUp() {
        // 初始化会话
        session = new MockHttpSession();
        
        // 生成PKCE参数
        generatePkceParameters();
        
        // 设置测试用户
        setupTestUser();
        
        // 配置内部客户端
        setupFirstPartyClient();
    }
    
    protected void completeOAuth2Flow() throws Exception {
        // 1. 登录获取认证令牌
        // 2. 请求授权码
        // 3. 交换访问令牌
        // 4. 验证令牌响应
    }
}
```

### 5.2 认证流程测试

1. OAuth2授权流程测试：
```java
class OAuth2AuthorizationIntegrationTest extends BaseOAuth2IntegrationTest {
    @Test
    void testAuthorizationCodeFlow() throws Exception {
        // 1. 测试授权请求
        // 2. 测试令牌交换
        // 3. 测试资源访问
    }
    
    @Test
    void testPkceRequired() throws Exception {
        // 验证PKCE要求
    }
    
    @Test
    void testInternalClientAutoApprove() throws Exception {
        // 验证内部客户端自动授权
    }
}
```

2. OIDC功能测试：
```java
class OidcIntegrationTest extends BaseOAuth2IntegrationTest {
    @Test
    void testUserInfo() throws Exception {
        // 验证用户信息端点
    }
    
    @Test
    void testOpenIDConfiguration() throws Exception {
        // 验证OIDC配置端点
    }
    
    @Test
    void testJwks() throws Exception {
        // 验证JWKS端点
    }
    
    @Test
    void testSessionManagement() throws Exception {
        // 验证会话管理
    }
}
```

3. 客户端管理测试：
```java
class ClientControllerIntegrationTest extends BaseOAuth2IntegrationTest {
    @Test
    void testCreateOidcClient() throws Exception {
        // 创建支持OIDC的客户端
    }
    
    @Test
    void testInternalClientCreation() throws Exception {
        // 创建内部客户端
    }
}
```

### 5.3 服务层测试

1. 授权服务测试：
```java
class AuthorizationServiceTest {
    @Test
    void testCreateAuthorizationRequest() {
        // 测试授权请求创建
    }
    
    @Test
    void testOpenIdScopeValidation() {
        // 测试OIDC scope验证
    }
}
```

2. OIDC服务测试：
```java
class OidcAuthorizationServiceTest {
    @Test
    void testValidateAuthorizationRequest() {
        // 测试OIDC授权请求验证
    }
    
    @Test
    void testNonceHandling() {
        // 测试nonce处理
    }
}
```

### 5.4 安全测试

1. 认证测试：
```java
class SecurityTest extends BaseOAuth2IntegrationTest {
    @Test
    void testUnauthorizedAccess() {
        // 测试未授权访问
    }
    
    @Test
    void testInvalidToken() {
        // 测试无效令牌
    }
    
    @Test
    void testTokenRevocation() {
        // 测试令牌撤销
    }
}
```

2. 会话管理测试：
```java
class SessionManagementTest {
    @Test
    void testSessionTimeout() {
        // 测试会话超时
    }
    
    @Test
    void testConcurrentSessions() {
        // 测试并发会话
    }
}
```

### 5.5 测试数据准备

1. 测试用户数据：
```sql
INSERT INTO users (username, password, email, given_name, family_name)
VALUES ('testuser', '$2a$10$...', 'test@example.com', 'Test', 'User');

INSERT INTO user_roles (user_id, role_id)
VALUES (1, 1);
```

2. 测试客户端数据：
```sql
INSERT INTO oauth2_registered_client (
    client_id, client_name, client_secret,
    authorization_grant_types, redirect_uris,
    scopes, client_settings, token_settings,
    is_internal, auto_approve
)
VALUES (
    'test-client',
    'Test Client',
    '$2a$10$...',
    'authorization_code refresh_token',
    'http://localhost:3000/callback',
    'openid profile email',
    '{"requireProofKey": true}',
    '{"accessTokenTimeToLive": "PT1H"}',
    true,
    true
);
```

### 5.6 测试覆盖要求

1. 功能测试覆盖：
   - OAuth2授权流程
   - OIDC标准实现
   - 客户端管理
   - 用户认证
   - 会话管理

2. 安全测试覆盖：
   - PKCE实现
   - 令牌验证
   - 授权验证
   - 会话安全
   - CSRF防护

3. 边界测试覆盖：
   - 错误处理
   - 超时处理
   - 并发处理
   - 参数验证

4. 性能测试覆盖：
   - 响应时间
   - 并发处理
   - 资源使用

## 6. 注意事项

1. 确保所有客户端都更新为使用OAuth2流程
2. 保持OIDC功能的完整性
3. 确保PKCE在所有客户端中正确实现
4. 维护好会话状态
5. 正确处理错误响应
6. 保持内部客户端的自动授权功能

## 7. 回滚计划

1. 保留原有代码的Git标签
2. 准备数据库回滚脚本
3. 分步实施，每步都可以独立回滚
4. 设置监控指标，及时发现问题

## 8. 验证清单

- [ ] 移除了所有直接API认证端点
- [ ] 表单登录正确集成到OAuth2流程
- [ ] OAuth2授权流程正常工作
- [ ] OIDC功能正常
- [ ] PKCE正确实现
- [ ] 所有测试通过
- [ ] API文档已更新
- [ ] 客户端配置已更新
- [ ] 会话管理正常
- [ ] 错误处理完善
- [ ] 性能测试通过
- [ ] 安全测试通过

## 9. 客户端管理

### 9.1 客户端配置

1. 基础客户端配置：
```java
@Service
public class ClientService {
    public ClientResponse createClient(CreateClientRequest request) {
        // 构建ClientSettings
        ClientSettings clientSettings = ClientSettings.builder()
                .requireAuthorizationConsent(!Boolean.TRUE.equals(request.getAutoApprove()))
                .requireProofKey(true)
                .build();

        // 构建客户端
        RegisteredClient client = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId(request.getClientId())
                .clientSecret(passwordEncoder.encode(request.getClientSecret()))
                .clientName(request.getClientName())
                .clientIdIssuedAt(Instant.now())
                .clientAuthenticationMethods(methods -> 
                    request.getAuthenticationMethods().forEach(method -> 
                        methods.add(resolveClientAuthenticationMethod(method))))
                .authorizationGrantTypes(types -> 
                    request.getAuthorizationGrantTypes().forEach(type -> 
                        types.add(resolveAuthorizationGrantType(type))))
                .scopes(scopes -> 
                    request.getScopes().forEach(scopes::add))
                .clientSettings(clientSettings)
                .tokenSettings(TokenSettings.builder()
                        .accessTokenTimeToLive(Duration.ofHours(1))
                        .refreshTokenTimeToLive(Duration.ofDays(30))
                .build();

        // 保存客户端
        clientRepository.save(client, request.getIsInternal(), request.getAutoApprove());
        return toClientResponse(client, request.getIsInternal(), request.getAutoApprove());
    }
}
```

2. 预置客户端配置：
```java
@Service
public class DatabaseInitService {
    private void initWebClient() {
        CreateClientRequest request = new CreateClientRequest();
        request.setClientId("web-client");
        request.setClientName("Web应用");
        request.setClientSecret(webClientSecret);
        request.setAuthenticationMethods(Set.of("client_secret_basic"));
        request.setAuthorizationGrantTypes(Set.of(
            "authorization_code",
            "refresh_token"
        ));
        request.setRedirectUris(Set.of(
            "http://localhost:3000/callback",
            "https://oauth.double2and9.com/callback"
        ));
        request.setScopes(Set.of(
            "openid",
            "profile",
            "email"
        ));
        request.setIsInternal(true);
        request.setAutoApprove(true);
        
        clientService.createClient(request);
    }
}
```

### 9.2 客户端存储

1. 自定义客户端仓库：
```java
@Repository
public class CustomJdbcRegisteredClientRepository extends JdbcRegisteredClientRepository {
    @Transactional
    public void save(RegisteredClient registeredClient, Boolean isInternal, Boolean autoApprove) {
        // 保存基本信息
        super.save(registeredClient);
        
        // 更新扩展信息
        String sql = "UPDATE oauth2_registered_client SET";
        boolean hasIsInternal = isInternal != null;
        boolean hasAutoApprove = autoApprove != null;
        
        if (hasIsInternal) {
            sql += " is_internal = ?";
        }
        
        if (hasIsInternal && hasAutoApprove) {
            sql += ",";
        }
        
        if (hasAutoApprove) {
            sql += " auto_approve = ?";
        }
        
        sql += " WHERE id = ?";
        
        // 执行更新
        if (hasIsInternal && hasAutoApprove) {
            jdbcTemplate.update(sql, isInternal, autoApprove, registeredClient.getId());
        } else if (hasIsInternal) {
            jdbcTemplate.update(sql, isInternal, registeredClient.getId());
        } else if (hasAutoApprove) {
            jdbcTemplate.update(sql, autoApprove, registeredClient.getId());
        }
    }
}
```

### 9.3 客户端管理API

1. 创建客户端：
```http
POST /api/clients
Content-Type: application/json
Authorization: Bearer {admin_token}

{
    "clientId": "test-client",
    "clientSecret": "secret",
    "clientName": "Test Client",
    "authenticationMethods": ["client_secret_basic"],
    "authorizationGrantTypes": ["authorization_code", "refresh_token"],
    "redirectUris": ["http://localhost:8080/callback"],
    "scopes": ["openid", "profile", "email"],
    "isInternal": false,
    "autoApprove": false
}
```

2. 更新客户端：
```http
PUT /api/clients/{clientId}
Content-Type: application/json
Authorization: Bearer {admin_token}

{
    "clientName": "Updated Client",
    "clientSecret": "new-secret",
    "authenticationMethods": ["client_secret_basic"],
    "authorizationGrantTypes": ["authorization_code", "refresh_token"],
    "redirectUris": ["http://localhost:8080/callback"],
    "scopes": ["openid", "profile", "email"],
    "isInternal": true,
    "autoApprove": true
}
```

3. 删除客户端：
```http
DELETE /api/clients/{clientId}
Authorization: Bearer {admin_token}
```

### 9.4 客户端类型

1. 内部客户端：
   - 由系统自动创建和管理
   - 支持自动授权
   - 默认启用PKCE
   - 示例：Web应用、移动应用

2. 外部客户端：
   - 由管理员手动创建
   - 需要用户确认授权
   - 强制要求PKCE
   - 示例：第三方应用

### 9.5 安全配置

1. 客户端认证：
```java
@Service
public class TokenService {
    private RegisteredClient validateClient(String clientId, String clientSecret) {
        RegisteredClient client = clientRepository.findByClientId(clientId);
        if (client == null || !passwordEncoder.matches(clientSecret, client.getClientSecret())) {
            throw new AuthException(AuthErrorCode.INVALID_CLIENT_CREDENTIALS);
        }
        return client;
    }
}
```

2. 授权确认：
```java
@Service
public class AuthorizationService {
    public AuthorizationResponse createAuthorizationRequest(
            AuthorizationRequest request, Authentication authentication) {
        RegisteredClient client = clientRepository.findByClientId(request.getClientId());
        
        // 检查是否需要用户确认
        boolean requireConsent = !clientService.isAutoApproveClient(request.getClientId());
        if (requireConsent) {
            // 生成授权确认页面数据
            return buildConsentResponse(client, request);
        } else {
            // 自动授权
            return createAuthorization(client, request, authentication);
        }
    }
}
```

### 9.6 测试用例

1. 客户端管理测试：
```java
@SpringBootTest
class ClientControllerIntegrationTest extends BaseOAuth2IntegrationTest {
    @Test
    void createClient_WithOidcScopes_Success() throws Exception {
        CreateClientRequest request = new CreateClientRequest();
        request.setClientId("oidc-client");
        request.setClientSecret("secret");
        request.setClientName("OIDC Test Client");
        request.setScopes(Set.of("openid", "profile", "email"));
        
        mockMvc.perform(post("/api/clients")
                .contentType(MediaType.APPLICATION_JSON)
                .header("Authorization", "Bearer " + accessToken)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.clientId").value("oidc-client"))
                .andExpect(jsonPath("$.scopes").value(containsInAnyOrder(
                    "openid", "profile", "email")));
    }
}
```

### 9.7 注意事项

1. 客户端安全：
   - 使用强密码策略
   - 定期轮换客户端密钥
   - 限制授权范围
   - 验证重定向URI

2. 授权管理：
   - 内部客户端自动授权
   - 外部客户端必须确认
   - 记录授权历史
   - 支持撤销授权

3. 配置管理：
   - 强制启用PKCE
   - 合理的令牌过期时间
   - 限制刷新令牌使用
   - 监控异常行为

## 10. 令牌管理

### 10.1 令牌服务

1. JWT服务：
```java
@Service
public class JwtService {
    private static final int ACCESS_TOKEN_EXPIRES_IN = 3600;  // 1小时
    private static final int REFRESH_TOKEN_EXPIRES_IN = 2592000;  // 30天

    public String generateAccessToken(String userId, String clientId, String scope) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId);
        claims.put("clientId", clientId);
        claims.put("scope", scope);
        claims.put("type", "access_token");
        return generateToken(claims, ACCESS_TOKEN_EXPIRES_IN);
    }

    public String generateRefreshToken(String userId, String clientId, String scope) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId);
        claims.put("clientId", clientId);
        claims.put("scope", scope);
        claims.put("type", "refresh_token");
        return generateToken(claims, REFRESH_TOKEN_EXPIRES_IN);
    }

    public String generateIdToken(String userId, String clientId, String nonce) {
        User user = userRepository.findById(Long.valueOf(userId))
                .orElseThrow(() -> new AuthException(AuthErrorCode.USER_NOT_FOUND));

        Map<String, Object> claims = new HashMap<>();
        claims.put("iss", oidcConfig.getIssuer());
        claims.put("sub", userId);
        claims.put("aud", clientId);
        claims.put("auth_time", System.currentTimeMillis() / 1000);
        
        if (nonce != null) {
            claims.put("nonce", nonce);
        }

        // 用户信息claims
        claims.put("name", user.getUsername());
        claims.put("email", user.getEmail());
        claims.put("email_verified", user.getEmailVerified());
        // ... 其他用户信息

        return generateToken(claims, ACCESS_TOKEN_EXPIRES_IN);
    }
}
```

2. 令牌服务：
```java
@Service
public class TokenService {
    private static final String GRANT_TYPE_AUTHORIZATION_CODE = "authorization_code";
    private static final String GRANT_TYPE_REFRESH_TOKEN = "refresh_token";
    private static final String TOKEN_TYPE = "Bearer";
    private static final int ACCESS_TOKEN_EXPIRES_IN = 3600;

    public TokenResponse createToken(String clientId, String clientSecret, TokenRequest request) {
        RegisteredClient client = validateClient(clientId, clientSecret);
        
        return switch (request.getGrantType()) {
            case GRANT_TYPE_AUTHORIZATION_CODE -> 
                createTokenByAuthorizationCode(clientId, clientSecret, request);
            case GRANT_TYPE_REFRESH_TOKEN -> 
                refreshToken(clientId, clientSecret, request);
            default -> throw new AuthException(AuthErrorCode.INVALID_GRANT_TYPE);
        };
    }
}
```

### 10.2 令牌响应

1. 令牌响应格式：
```java
@Data
public class TokenResponse {
    @JsonProperty("access_token")
    private String accessToken;      // 访问令牌
    
    @JsonProperty("refresh_token")
    private String refreshToken;     // 刷新令牌
    
    @JsonProperty("id_token")
    private String idToken;          // ID Token（OIDC）
    
    @JsonProperty("token_type")
    private String tokenType;        // 令牌类型，固定为 "Bearer"
    
    @JsonProperty("expires_in")
    private Integer expiresIn;       // 访问令牌过期时间（秒）
    
    private String scope;            // 授权范围
}
```

### 10.3 令牌端点

1. 令牌颁发：
```http
POST /api/oauth2/token
Content-Type: application/x-www-form-urlencoded
Authorization: Basic {base64(client_id:client_secret)}

grant_type=authorization_code&
code=string&
redirect_uri=string&
code_verifier=string
```

2. 令牌刷新：
```http
POST /api/oauth2/token
Content-Type: application/x-www-form-urlencoded
Authorization: Basic {base64(client_id:client_secret)}

grant_type=refresh_token&
refresh_token=string&
scope=string
```

3. 令牌撤销：
```http
POST /api/oauth2/revoke
Content-Type: application/x-www-form-urlencoded
Authorization: Basic {base64(client_id:client_secret)}

token=string&
token_type_hint=access_token
```

### 10.4 令牌验证

1. 令牌内省：
```java
@Service
public class JwtService {
    public TokenIntrospectionResponse introspectToken(String token) {
        try {
            // 检查令牌是否在黑名单中
            if (tokenBlacklistService.isBlacklisted(token)) {
                return TokenIntrospectionResponse.builder()
                    .active(false)
                    .build();
            }

            Claims claims = jwtTokenProvider.validateToken(token);
            return TokenIntrospectionResponse.builder()
                .active(true)
                .userId(claims.get("userId", String.class))
                .clientId(claims.get("clientId", String.class))
                .scope(claims.get("scope", String.class))
                .exp(claims.getExpiration().getTime() / 1000)
                .iat(claims.getIssuedAt().getTime() / 1000)
                .tokenType(claims.get("type", String.class))
                .build();
        } catch (Exception e) {
            return TokenIntrospectionResponse.builder()
                .active(false)
                .build();
        }
    }
}
```

### 10.5 令牌安全

1. 令牌黑名单：
```java
@Service
public class TokenBlacklistService {
    private static final String BLACKLIST_KEY_PREFIX = "token:blacklist:";
    private static final long DEFAULT_BLACKLIST_TTL = 24 * 60 * 60; // 24小时

    public void blacklistToken(String token, Claims claims) {
        String key = BLACKLIST_KEY_PREFIX + token;
        long ttl = calculateTTL(claims.getExpiration());
        redisTemplate.opsForValue().set(key, "1", ttl, TimeUnit.SECONDS);
    }

    public boolean isBlacklisted(String token) {
        String key = BLACKLIST_KEY_PREFIX + token;
        return Boolean.TRUE.equals(redisTemplate.hasKey(key));
    }
}
```

2. 令牌验证过滤器：
```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response, FilterChain chain) {
        try {
            String token = extractToken(request);
            if (token != null) {
                // 验证令牌
                Claims claims = jwtTokenProvider.validateToken(token);
                
                // 检查令牌是否被撤销
                if (tokenBlacklistService.isBlacklisted(token)) {
                    handleAuthenticationError(response, 
                        AuthErrorCode.TOKEN_REVOKED);
                    return;
                }
                
                // 设置认证信息
                UserDetails userDetails = userDetailsService
                    .loadUserById(claims.get("userId", String.class));
                UsernamePasswordAuthenticationToken authentication = 
                    new UsernamePasswordAuthenticationToken(
                        userDetails, token, userDetails.getAuthorities());
                SecurityContextHolder.getContext()
                    .setAuthentication(authentication);
            }
            chain.doFilter(request, response);
        } catch (Exception e) {
            handleAuthenticationError(response, e);
        }
    }
}
```

### 10.6 测试用例

1. JWT服务测试：
```java
@ExtendWith(MockitoExtension.class)
class JwtServiceTest {
    @Test
    void generateAccessToken_Success() {
        String token = jwtService.generateAccessToken("1", "testClient", "read write");
        assertNotNull(token);
        
        Claims claims = jwtService.validateToken(token);
        assertEquals("1", claims.get("userId"));
        assertEquals("testClient", claims.get("clientId"));
        assertEquals("read write", claims.get("scope"));
        assertEquals("access_token", claims.get("type"));
    }
    
    @Test
    void introspectToken_WhenBlacklisted_ReturnInactive() {
        when(tokenBlacklistService.isBlacklisted(TEST_TOKEN)).thenReturn(true);
        
        TokenIntrospectionResponse response = jwtService.introspectToken(TEST_TOKEN);
        
        assertFalse(response.isActive());
    }
}
```

### 10.7 注意事项

1. 令牌安全：
   - 使用适当的签名算法（RS256）
   - 设置合理的过期时间
   - 实现令牌撤销机制
   - 验证令牌类型

2. 令牌管理：
   - 维护令牌黑名单
   - 处理令牌刷新
   - 清理过期令牌
   - 监控异常使用

3. 性能优化：
   - 使用Redis缓存
   - 异步处理撤销
   - 定期清理过期数据
   - 优化验证流程

## 11. 授权流程

### 11.1 授权服务

1. 授权请求处理：
```java
@Service
public class AuthorizationService {
    public AuthorizationResponse createAuthorizationRequest(
            AuthorizationRequest request, Authentication authentication) {
        // 验证用户认证状态
        if (!authentication.isAuthenticated()) {
            throw new AuthException(AuthErrorCode.AUTHENTICATION_FAILED);
        }

        // 验证客户端
        RegisteredClient client = clientRepository.findByClientId(request.getClientId());
        if (client == null) {
            throw new AuthException(AuthErrorCode.CLIENT_NOT_FOUND);
        }

        // 验证PKCE参数
        if (request.getCodeChallenge() == null || request.getCodeChallengeMethod() == null) {
            throw new AuthException(AuthErrorCode.PKCE_REQUIRED);
        }

        // 创建授权响应
        AuthorizationResponse response = new AuthorizationResponse();
        response.setClientId(client.getClientId());
        response.setClientName(client.getClientName());
        response.setRequestedScopes(requestedScopes);
        response.setState(request.getState());
        response.setAuthorizationId(UUID.randomUUID().toString());
        response.setRedirectUri(request.getRedirectUri());
        response.setCodeChallenge(request.getCodeChallenge());
        response.setCodeChallengeMethod(request.getCodeChallengeMethod());

        // 处理内部客户端自动授权
        if (clientService.isInternalClient(client.getClientId()) && 
            clientService.isAutoApproveClient(client.getClientId())) {
            String authorizationCode = authorizationConsentService.consent(
                createConsentRequest(request, authentication));
            response.setAuthorizationCode(authorizationCode);
        } else {
            // 保存授权请求等待用户确认
            authorizationConsentService.savePendingAuthorization(
                response.getAuthorizationId(), response);
        }

        return response;
    }
}
```

2. 授权确认服务：
```java
@Service
public class AuthorizationConsentService {
    private static final String REDIS_KEY_PREFIX = "oauth2:auth:request:";
    private static final long AUTHORIZATION_REQUEST_TIMEOUT = 10; // 10分钟过期

    public AuthorizationConsentResponse consent(
            AuthorizationConsentRequest request, Authentication authentication) {
        // 验证用户认证状态
        if (!authentication.isAuthenticated()) {
            throw new AuthException(AuthErrorCode.UNAUTHORIZED);
        }

        // 获取待处理的授权请求
        String key = REDIS_KEY_PREFIX + request.getAuthorizationId();
        AuthorizationResponse authRequest = (AuthorizationResponse) 
            redisTemplate.opsForValue().get(key);
        if (authRequest == null) {
            throw new AuthException(AuthErrorCode.AUTHORIZATION_REQUEST_NOT_FOUND);
        }

        // 生成授权码
        String code = authorizationCodeService.createAuthorizationCode(
            authRequest.getClientId(),
            authentication.getName(),
            authRequest.getRedirectUri(),
            String.join(" ", request.getApprovedScopes()),
            request.getCodeChallenge(),
            request.getCodeChallengeMethod()
        );

        // 创建响应
        AuthorizationConsentResponse response = new AuthorizationConsentResponse();
        response.setAuthorizationCode(code);
        response.setState(authRequest.getState());
        response.setRedirectUri(authRequest.getRedirectUri());

        // 清理Redis中的授权请求
        redisTemplate.delete(key);

        return response;
    }
}
```

### 11.2 授权请求

1. 授权请求参数：
```java
@Data
public class OAuth2AuthorizationRequest implements Serializable {
    private String clientId;           // 客户端ID
    private String scope;              // 权限范围
    private String state;              // 防CSRF参数
    private String redirectUri;        // 重定向URI
    private String responseType;       // 响应类型，固定为"code"
    private String codeChallenge;      // PKCE挑战码
    private String codeChallengeMethod;// PKCE挑战方法
    private String nonce;              // OIDC防重放参数
    private boolean continueAuthorization; // 继续授权标志
}
```

2. 授权响应：
```java
@Data
public class AuthorizationResponse {
    private String clientId;           // 客户端ID
    private String clientName;         // 客户端名称
    private Set<String> requestedScopes; // 请求的权限范围
    private String state;              // 原样返回state
    private String authorizationId;    // 授权请求ID
    private String redirectUri;        // 重定向URI
    private String codeChallenge;      // PKCE挑战码
    private String codeChallengeMethod;// PKCE挑战方法
    private String authorizationCode;  // 授权码（自动授权时使用）
}
```

### 11.3 授权确认

1. 确认请求：
```java
@Data
public class AuthorizationConsentRequest {
    @NotBlank(message = "授权ID不能为空")
    private String authorizationId;    // 授权请求ID
    
    @NotEmpty(message = "授权范围不能为空")
    private Set<String> approvedScopes;// 用户同意的权限范围
    private String codeChallenge;      // PKCE挑战码
    private String codeChallengeMethod;// PKCE挑战方法
}
```

2. 确认响应：
```java
@Data
public class AuthorizationConsentResponse {
    private String authorizationCode;  // 授权码
    private String state;              // 原样返回state
    private String redirectUri;        // 重定向URI
}
```

### 11.4 授权端点

1. 授权请求端点：
```java
@RestController
@RequestMapping("/api/oauth2")
public class AuthorizationController {
    @PostMapping("/authorize")
    public AuthorizationResponse authorize(
            @Valid @RequestBody AuthorizationRequest request,
            Authentication authentication) {
        return authorizationService.createAuthorizationRequest(
            request, authentication);
    }
}
```

2. 授权确认端点：
```java
@RestController
@RequestMapping("/api/oauth2")
public class AuthorizationConsentController {
    @PostMapping("/consent")
    public AuthorizationConsentResponse consent(
            @Valid @RequestBody AuthorizationConsentRequest request,
            Authentication authentication) {
        return authorizationConsentService.consent(request, authentication);
    }
}
```

### 11.5 授权页面

1. 确认页面模板：
```html
<form th:action="@{/oauth2/authorize}" method="post">
    <input type="hidden" name="client_id" th:value="${clientId}">
    <input type="hidden" name="state" th:value="${state}">
    
    <div th:each="scope : ${scopes}">
        <input type="hidden" name="scope" th:value="${scope}">
    </div>
    
    <div class="auth-actions">
        <button type="submit" name="consent" value="approve">批准</button>
        <button type="submit" name="consent" value="deny">拒绝</button>
    </div>
</form>
```

### 11.6 测试用例

1. 授权服务测试：
```java
@ExtendWith(MockitoExtension.class)
class AuthorizationServiceTest {
    @Test
    void createAuthorizationRequest_Success() {
        // 准备测试数据
        when(authentication.isAuthenticated()).thenReturn(true);
        when(clientRepository.findByClientId("test-client")).thenReturn(client);
        when(clientService.isInternalClient("test-client")).thenReturn(false);
        
        // 执行测试
        AuthorizationResponse response = authorizationService
            .createAuthorizationRequest(request, authentication);
        
        // 验证结果
        assertNotNull(response);
        assertEquals("test-client", response.getClientId());
        assertEquals("Test Client", response.getClientName());
        assertNotNull(response.getAuthorizationId());
    }
}
```

### 11.7 注意事项

1. 安全考虑：
   - 验证PKCE参数
   - 防止CSRF攻击
   - 验证重定向URI
   - 保护授权码

2. 流程管理：
   - 处理超时情况
   - 清理过期请求
   - 记录授权历史
   - 支持撤销授权

3. 用户体验：
   - 清晰的授权页面
   - 权限范围说明
   - 记住用户选择
   - 支持取消授权

## 12. 授权码管理

### 12.1 授权码服务

1. 授权码创建：
```java
@Service
public class AuthorizationCodeService {
    private static final int CODE_EXPIRES_IN = 10;  // 10分钟过期

    @Transactional
    public String createAuthorizationCode(String clientId, String username, 
            String redirectUri, String scope, String codeChallenge, 
            String codeChallengeMethod) {
        // 查找用户
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new AuthException(AuthErrorCode.USER_NOT_FOUND));

        // 生成授权码
        String code = generateCode();

        // 创建授权码记录
        AuthorizationCode authCode = new AuthorizationCode();
        authCode.setCode(code);
        authCode.setClientId(clientId);
        authCode.setUserId(user.getId().toString());
        authCode.setRedirectUri(redirectUri);
        authCode.setScope(scope);
        authCode.setCodeChallenge(codeChallenge);
        authCode.setCodeChallengeMethod(codeChallengeMethod);
        authCode.setExpiresAt(LocalDateTime.now().plusMinutes(CODE_EXPIRES_IN));
        authCode.setUsed(false);

        // 保存授权码
        authorizationCodeRepository.save(authCode);
        return code;
    }
}
```

2. PKCE工具类：
```java
public class PKCEUtils {
    public static boolean verifyCodeChallenge(
            String codeVerifier, String codeChallenge, String method) {
        if (codeVerifier == null || codeChallenge == null) {
            return false;
        }

        String computedChallenge = computeCodeChallenge(codeVerifier, method);
        return codeChallenge.equals(computedChallenge);
    }

    public static String computeCodeChallenge(String codeVerifier, String method) {
        if ("plain".equals(method)) {
            return codeVerifier;
        }
        
        if ("S256".equals(method)) {
            try {
                MessageDigest digest = MessageDigest.getInstance("SHA-256");
                byte[] hash = digest.digest(codeVerifier.getBytes(StandardCharsets.UTF_8));
                return Base64.getUrlEncoder().withoutPadding().encodeToString(hash);
            } catch (NoSuchAlgorithmException e) {
                throw new AuthException(AuthErrorCode.SYSTEM_ERROR);
            }
        }
        
        throw new AuthException(AuthErrorCode.INVALID_CODE_VERIFIER);
    }
}
```

### 12.2 数据模型

1. 授权码实体：
```java
@Entity
@Table(name = "oauth2_authorization_code")
public class AuthorizationCode {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String code;  // 授权码

    @Column(nullable = false)
    private String clientId;  // 客户端ID

    @Column(nullable = false)
    private String userId;  // 用户ID

    @Column(nullable = false)
    private String redirectUri;  // 重定向URI

    @Column(nullable = false)
    private String scope;  // 授权范围

    @Column(nullable = false)
    private LocalDateTime expiresAt;  // 过期时间

    @Column
    private String codeChallenge;  // PKCE挑战码

    @Column
    private String codeChallengeMethod;  // PKCE挑战方法

    @Column(nullable = false)
    private boolean used;  // 是否已使用

    @Column(nullable = false)
    private LocalDateTime createdAt;  // 创建时间
}
```

2. 数据库表：
```sql
CREATE TABLE oauth2_authorization_code (
    id VARCHAR(36) PRIMARY KEY,
    client_id VARCHAR(100) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    code VARCHAR(255) NOT NULL,
    scope VARCHAR(1000),
    redirect_uri VARCHAR(1000),
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    code_challenge VARCHAR(128),
    code_challenge_method VARCHAR(10)
);
```

### 12.3 令牌交换

1. 授权码验证：
```java
@Service
public class TokenService {
    private TokenResponse createTokenByAuthorizationCode(
            String clientId, String clientSecret, TokenRequest request) {
        // 验证客户端
        RegisteredClient client = validateClient(clientId, clientSecret);

        // 验证并消费授权码
        AuthorizationCode authCode = authorizationCodeService.validateAndConsume(
            request.getCode(),
            clientId,
            request.getRedirectUri()
        );

        // 验证PKCE
        if (authCode.getCodeChallenge() != null) {
            if (request.getCodeVerifier() == null) {
                throw new AuthException(AuthErrorCode.CODE_VERIFIER_REQUIRED);
            }

            boolean isValidVerifier = PKCEUtils.verifyCodeChallenge(
                request.getCodeVerifier(),
                authCode.getCodeChallenge(),
                authCode.getCodeChallengeMethod()
            );

            if (!isValidVerifier) {
                throw new AuthException(AuthErrorCode.INVALID_CODE_VERIFIER);
            }
        }

        // 生成令牌
        String accessToken = jwtService.generateAccessToken(
            authCode.getUserId(),
            clientId,
            authCode.getScope()
        );

        String refreshToken = jwtService.generateRefreshToken(
            authCode.getUserId(),
            clientId,
            authCode.getScope()
        );

        // 生成ID Token（如果请求包含openid scope）
        String idToken = null;
        if (authCode.getScope().contains("openid")) {
            idToken = jwtService.generateIdToken(
                authCode.getUserId(),
                clientId,
                request.getNonce()
            );
        }

        // 创建响应
        TokenResponse response = new TokenResponse();
        response.setAccessToken(accessToken);
        response.setRefreshToken(refreshToken);
        response.setIdToken(idToken);
        response.setTokenType("Bearer");
        response.setExpiresIn(3600);
        response.setScope(authCode.getScope());

        return response;
    }
}
```

### 12.4 测试用例

1. PKCE测试：
```java
class PKCEUtilsTest {
    private static final String CODE_VERIFIER = "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk";
    private static final String CODE_CHALLENGE_PLAIN = "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk";
    private static final String CODE_CHALLENGE_S256 = "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM";

    @Test
    void verifyCodeChallenge_Success_Plain() {
        assertTrue(PKCEUtils.verifyCodeChallenge(
            CODE_VERIFIER,
            CODE_CHALLENGE_PLAIN,
            "plain"
        ));
    }

    @Test
    void verifyCodeChallenge_Success_S256() {
        assertTrue(PKCEUtils.verifyCodeChallenge(
            CODE_VERIFIER,
            CODE_CHALLENGE_S256,
            "S256"
        ));
    }
}
```

2. 授权码服务测试：
```java
class AuthorizationServiceTest {
    @Test
    void createAuthorizationRequest_WithValidPKCE_Success() {
        when(authentication.isAuthenticated()).thenReturn(true);
        when(clientRepository.findByClientId("test-client")).thenReturn(client);
        when(clientService.isInternalClient("test-client")).thenReturn(false);

        AuthorizationResponse response = authorizationService
            .createAuthorizationRequest(request, authentication);

        assertNotNull(response);
        assertEquals(request.getCodeChallenge(), response.getCodeChallenge());
        assertEquals(request.getCodeChallengeMethod(), response.getCodeChallengeMethod());
    }

    @Test
    void createAuthorizationRequest_WithoutPKCE_ThrowsException() {
        request.setCodeChallenge(null);
        request.setCodeChallengeMethod(null);
        
        when(authentication.isAuthenticated()).thenReturn(true);
        when(clientRepository.findByClientId("test-client")).thenReturn(client);

        AuthException exception = assertThrows(AuthException.class, () -> 
            authorizationService.createAuthorizationRequest(request, authentication));
        
        assertEquals(AuthErrorCode.PKCE_REQUIRED, exception.getErrorCode());
    }
}
```

### 12.5 注意事项

1. 安全考虑：
   - 强制使用PKCE
   - 验证重定向URI
   - 设置合理的过期时间
   - 一次性使用授权码

2. 错误处理：
   - 授权码过期
   - 授权码已使用
   - PKCE验证失败
   - 客户端验证失败

3. 性能优化：
   - 定期清理过期授权码
   - 使用索引优化查询
   - 异步处理日志
   - 缓存热点数据
